"use client";

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 robotic_hand.glb --typescript 
Author: SeanNicolas (https://sketchfab.com/SeanNicolas)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/robotic-hand-3e284b06bbb84d858f85f7a246cd65df
Title: Robotic Hand - OPTIMIZED FOR NEXT.JS + TURBOPACK
*/

import React, { JSX, useMemo, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import * as THREE from "three";

// Types
interface GLTFResult extends GLTF {
  nodes: Record<string, THREE.Mesh>;
  materials: Record<string, THREE.Material>;
}

type ModelProps = JSX.IntrinsicElements["group"];

interface BaseConfig {
  readonly name: string;
  readonly pos: readonly [number, number, number];
  readonly rot?: readonly [number, number, number];
  readonly scale: readonly [number, number, number] | number;
}

type ComponentConfig = BaseConfig;

interface CubeConfig extends BaseConfig {
  readonly mats: readonly string[];
}

interface MeshConfig extends BaseConfig {
  readonly material: string;
}

// Constants
const COMPONENTS_CONFIG: readonly ComponentConfig[] = [
  {
    name: "Cylinder018",
    pos: [3.837, 0.467, -2.673],
    scale: [0.061, 0.061, 0.525],
  },
  {
    name: "Cylinder017",
    pos: [3.972, -0.889, -0.146],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.163, 0.163, 0.105],
  },
  {
    name: "Cylinder016",
    pos: [3.903, -0.889, 0.962],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.117, 0.117, 0.084],
  },
  {
    name: "Cylinder015",
    pos: [3.965, -0.889, 0.396],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.136, 0.136, 0.098],
  },
  {
    name: "Cylinder014",
    pos: [4.062, -0.425, 0.722],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.165, 0.165, 0.119],
  },
  {
    name: "Cylinder013",
    pos: [3.986, -0.425, 1.406],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.141, 0.141, 0.102],
  },
  {
    name: "Cylinder012",
    pos: [4.07, -0.425, 0.065],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.198, 0.198, 0.127],
  },
  {
    name: "Cylinder011",
    pos: [4.144, 0.096, 0.912],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.165, 0.165, 0.126],
  },
  {
    name: "Cylinder010",
    pos: [4.069, 0.096, 1.642],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.141, 0.141, 0.107],
  },
  {
    name: "Cylinder009",
    pos: [4.159, 0.096, 0.197],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.198, 0.198, 0.113],
  },
  {
    name: "Cylinder008",
    pos: [4.107, 0.654, 0.198],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.198, 0.198, 0.113],
  },
  {
    name: "Cylinder007",
    pos: [4.023, 0.654, 1.539],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.141, 0.141, 0.107],
  },
  {
    name: "Cylinder006",
    pos: [4.099, 0.654, 0.855],
    rot: [Math.PI / 2, 0, Math.PI / 2],
    scale: [0.165, 0.165, 0.126],
  },
  {
    name: "Cylinder005",
    pos: [3.175, 1.344, -0.313],
    rot: [2.076, -1.1, 2.443],
    scale: 0.131,
  },
  {
    name: "Cylinder004",
    pos: [3.364, 1.108, -0.919],
    rot: [2.127, -1.07, 2.488],
    scale: 0.153,
  },
  {
    name: "Cylinder001",
    pos: [3.837, -0.544, -3.479],
    scale: [0.116, 0.116, 1],
  },
  { name: "Cylinder", pos: [3.863, 0, -3.604], scale: 0.58 },
] as const;

const CUBE_CONFIGS: readonly CubeConfig[] = [
  {
    name: "Cube037",
    pos: [3.924, -0.883, 0.92],
    rot: [0, -Math.PI / 2, 0],
    scale: [0.819, 0.775, 0.819],
    mats: ["Material.012", "Material.000"],
  },
  {
    name: "Cube035",
    pos: [3.922, -0.883, 0.92],
    rot: [0, -Math.PI / 2, 0],
    scale: [0.819, 0.775, 0.819],
    mats: ["Material.012", "Material.009"],
  },
  {
    name: "Cube034",
    pos: [4.01, -0.417, 1.356],
    rot: [0, -Math.PI / 2, 0],
    scale: [0.991, 0.938, 0.991],
    mats: ["Material.012", "Material.009"],
  },
  {
    name: "Cube032",
    pos: [4.012, -0.417, 1.356],
    rot: [0, -Math.PI / 2, 0],
    scale: [0.991, 0.938, 0.991],
    mats: ["Material.012", "Material.000"],
  },
  {
    name: "Cube031",
    pos: [4.098, 0.104, 1.602],
    rot: [0, -Math.PI / 2, 0],
    scale: [1.115, 0.991, 0.991],
    mats: ["Material.012", "Material.009"],
  },
  {
    name: "Cube029",
    pos: [4.1, 0.104, 1.602],
    rot: [0, -Math.PI / 2, 0],
    scale: [1.115, 0.991, 0.991],
    mats: ["Material.012", "Material.000"],
  },
  {
    name: "Cube028",
    pos: [4.049, 0.662, 1.488],
    rot: [0, -Math.PI / 2, 0],
    scale: 0.991,
    mats: ["Material.012", "Material.000"],
  },
  {
    name: "Cube026",
    pos: [4.047, 0.662, 1.488],
    rot: [0, -Math.PI / 2, 0],
    scale: 0.991,
    mats: ["Material.012", "Material.009"],
  },
  {
    name: "Cube019",
    pos: [3.756, 0.008, -3.942],
    rot: [0, -Math.PI / 2, 0],
    scale: 0.991,
    mats: ["Material.012", "Material.000"],
  },
  {
    name: "Cube014",
    pos: [3.809, 0, -4.035],
    rot: [0, -Math.PI / 2, 0],
    scale: 0.991,
    mats: ["Material.012", "Material.009", "Material.013"],
  },
] as const;

const INDIVIDUAL_MESHES: readonly MeshConfig[] = [
  {
    name: "Cylinder002_0",
    material: "Material.011",
    pos: [3.835, 0.556, -1.312],
    rot: [0, -Math.PI / 2, 0],
    scale: [0.347, 0.347, 0.381],
  },
  {
    name: "Cube036_0",
    material: "Material.012",
    pos: [3.923, -0.883, 0.92],
    rot: [0, -Math.PI / 2, 0],
    scale: [0.819, 0.775, 0.819],
  },
  {
    name: "Cube033_0",
    material: "Material.012",
    pos: [4.011, -0.417, 1.356],
    rot: [0, -Math.PI / 2, 0],
    scale: [0.991, 0.938, 0.991],
  },
  {
    name: "Cube030_0",
    material: "Material.012",
    pos: [4.1, 0.104, 1.602],
    rot: [0, -Math.PI / 2, 0],
    scale: [1.115, 0.991, 0.991],
  },
  {
    name: "Cube027_0",
    material: "Material.012",
    pos: [4.048, 0.662, 1.488],
    rot: [0, -Math.PI / 2, 0],
    scale: 0.991,
  },
  {
    name: "Cube025_0",
    material: "Material.010",
    pos: [3.94, -0.036, -1.895],
    rot: [0, -Math.PI / 2, 0],
    scale: [0.376, 0.376, 0.193],
  },
  {
    name: "Cube018_0",
    material: "Material.012",
    pos: [3.756, -0.017, -3.942],
    rot: [0, -Math.PI / 2, 0],
    scale: 0.991,
  },
  {
    name: "Cube017_0",
    material: "Material.012",
    pos: [3.809, -0.014, -4.035],
    rot: [0, -Math.PI / 2, 0],
    scale: 0.991,
  },
] as const;

const CYLINDER_MATERIALS = [
  "Material.009",
  "Material.010",
  "Material.011",
] as const;
const SPHERE_MATERIALS = [
  "Material.000",
  "Material.011",
  "Material.010",
] as const;

// Utility functions
const normalizeScale = (
  scale: readonly [number, number, number] | number
): [number, number, number] =>
  typeof scale === "number" ? [scale, scale, scale] : [...scale];

const createMeshElement = (
  key: string,
  geometry: THREE.BufferGeometry,
  material: THREE.Material,
  config?: {
    pos?: readonly [number, number, number];
    rot?: readonly [number, number, number];
    scale?: readonly [number, number, number] | number;
  }
): JSX.Element => (
  <mesh
    key={key}
    geometry={geometry}
    material={material}
    position={config?.pos ? [...config.pos] : undefined}
    rotation={config?.rot ? [...config.rot] : undefined}
    scale={config?.scale ? normalizeScale(config.scale) : undefined}
  />
);

// Optimized components
// eslint-disable-next-line react/display-name
const CylinderGroup = React.memo<{
  config: ComponentConfig;
  nodes: GLTFResult["nodes"];
  materials: GLTFResult["materials"];
}>(({ config, nodes, materials }) => {
  const meshElements = useMemo(() => {
    const elements: JSX.Element[] = [];

    for (let i = 0; i < 3; i++) {
      const node = nodes[`${config.name}_${i}`];
      const material = materials[CYLINDER_MATERIALS[i]];

      if (node?.geometry && material) {
        elements.push(
          createMeshElement(`${config.name}-${i}`, node.geometry, material)
        );
      }
    }

    return elements;
  }, [config.name, nodes, materials]);

  return (
    <group
      position={[...config.pos]}
      rotation={config.rot ? [...config.rot] : undefined}
      scale={normalizeScale(config.scale)}
    >
      {meshElements}
    </group>
  );
});

// eslint-disable-next-line react/display-name
const CubeGroup = React.memo<{
  config: CubeConfig;
  nodes: GLTFResult["nodes"];
  materials: GLTFResult["materials"];
}>(({ config, nodes, materials }) => {
  const meshElements = useMemo(() => {
    const elements: JSX.Element[] = [];

    config.mats.forEach((matName, i) => {
      const node = nodes[`${config.name}_${i}`];
      const material = materials[matName];

      if (node?.geometry && material) {
        elements.push(
          createMeshElement(`${config.name}-${i}`, node.geometry, material)
        );
      }
    });

    return elements;
  }, [config.name, config.mats, nodes, materials]);

  return (
    <group
      position={[...config.pos]}
      rotation={config.rot ? [...config.rot] : undefined}
      scale={normalizeScale(config.scale)}
    >
      {meshElements}
    </group>
  );
});

// eslint-disable-next-line react/display-name
const SphereGroup = React.memo<{
  nodes: GLTFResult["nodes"];
  materials: GLTFResult["materials"];
}>(({ nodes, materials }) => {
  const sphereMeshes = useMemo(() => {
    const elements: JSX.Element[] = [];

    SPHERE_MATERIALS.forEach((matName, i) => {
      const node = nodes[`Sphere008_${i}`];
      const material = materials[matName];

      if (node?.geometry && material) {
        elements.push(
          createMeshElement(`sphere-${i}`, node.geometry, material)
        );
      }
    });

    return elements;
  }, [nodes, materials]);

  return (
    <group
      position={[3.709, 0.557, -1.315]}
      rotation={[Math.PI / 2, -0.509, Math.PI / 2]}
      scale={0.332}
    >
      {sphereMeshes}
    </group>
  );
});

// Main component
export const Model = React.memo<ModelProps>((props) => {
  const { nodes, materials } = useGLTF(
    "/assets/models/robotic_hand.glb"
  ) as unknown as GLTFResult;
  const groupRef = useRef<THREE.Group>(null);

  // Memoize all component groups
  const cylinderComponents = useMemo(
    () =>
      COMPONENTS_CONFIG.map((config, i) => (
        <CylinderGroup
          key={`cyl-${i}`}
          config={config}
          nodes={nodes}
          materials={materials}
        />
      )),
    [nodes, materials]
  );

  const cubeComponents = useMemo(
    () =>
      CUBE_CONFIGS.map((config, i) => (
        <CubeGroup
          key={`cube-${i}`}
          config={config}
          nodes={nodes}
          materials={materials}
        />
      )),
    [nodes, materials]
  );

  const individualMeshes = useMemo(() => {
    const elements: JSX.Element[] = [];

    INDIVIDUAL_MESHES.forEach((meshConfig, i) => {
      const node = nodes[meshConfig.name];
      const material = materials[meshConfig.material];

      if (node?.geometry && material) {
        elements.push(
          createMeshElement(`ind-${i}`, node.geometry, material, {
            pos: meshConfig.pos,
            rot: meshConfig.rot,
            scale: meshConfig.scale,
          })
        );
      }
    });

    return elements;
  }, [nodes, materials]);

  return (
    <group {...props} ref={groupRef} dispose={null}>
      <group rotation={[Math.PI / 2, -Math.PI / 2, 0]}>
        <SphereGroup nodes={nodes} materials={materials} />
        {cylinderComponents}
        {cubeComponents}
        {individualMeshes}
      </group>
    </group>
  );
});

Model.displayName = "RoboticHandModel";

// Preload
useGLTF.preload("/assets/models/robotic_hand.glb");

export default Model;
